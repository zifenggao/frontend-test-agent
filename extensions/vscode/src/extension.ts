import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { TestGenerator } from './testGenerator';
import { TestRunner } from './testRunner';
import { CoverageReporter } from './coverageReporter';
import { ResultAnalyzer } from './resultAnalyzer';
import { TestExplorerProvider } from './testExplorer';

let testGenerator: TestGenerator;
let testRunner: TestRunner;
let coverageReporter: CoverageReporter;
let resultAnalyzer: ResultAnalyzer;
let testExplorerProvider: TestExplorerProvider;

export function activate(context: vscode.ExtensionContext) {
    console.log('Frontend Test Agent has been activated!');

    // Initialize services
    const config = vscode.workspace.getConfiguration('frontend-test-agent');
    testGenerator = new TestGenerator(config);
    testRunner = new TestRunner(config);
    coverageReporter = new CoverageReporter(config);
    resultAnalyzer = new ResultAnalyzer(config);
    testExplorerProvider = new TestExplorerProvider();

    // Register commands
    const generateTestsCommand = vscode.commands.registerCommand(
        'frontend-test-agent.generateTests',
        async (uri: vscode.Uri) => {
            await handleGenerateTests(uri);
        }
    );

    const runTestsCommand = vscode.commands.registerCommand(
        'frontend-test-agent.runTests',
        async (uri: vscode.Uri) => {
            await handleRunTests(uri);
        }
    );

    const showCoverageCommand = vscode.commands.registerCommand(
        'frontend-test-agent.showCoverage',
        async () => {
            await handleShowCoverage();
        }
    );

    const analyzeResultsCommand = vscode.commands.registerCommand(
        'frontend-test-agent.analyzeResults',
        async () => {
            await handleAnalyzeResults();
        }
    );

    // Register views
    vscode.window.registerTreeDataProvider(
        'frontend-test-agent.testExplorer',
        testExplorerProvider
    );

    // Register document save listener for auto-generate
    const autoGenerateDisposable = vscode.workspace.onDidSaveTextDocument(
        async (document) => {
            await handleAutoGenerate(document);
        }
    );

    // Add to subscriptions
    context.subscriptions.push(
        generateTestsCommand,
        runTestsCommand,
        showCoverageCommand,
        analyzeResultsCommand,
        autoGenerateDisposable
    );

    // Show welcome message
    showWelcomeMessage();
}

async function handleGenerateTests(uri?: vscode.Uri) {
    let filePath: string | undefined;

    if (uri) {
        filePath = uri.fsPath;
    } else if (vscode.window.activeTextEditor) {
        filePath = vscode.window.activeTextEditor.document.fileName;
    } else {
        vscode.window.showErrorMessage('No file selected to generate tests for');
        return;
    }

    try {
        const progressOptions: vscode.ProgressOptions = {
            location: vscode.ProgressLocation.Notification,
            title: 'Generating Tests...',
            cancellable: false
        };

        await vscode.window.withProgress(progressOptions, async (progress) => {
            progress.report({ increment: 0, message: 'Analyzing component...' });
            
            const content = fs.readFileSync(filePath, 'utf8');
            const config = vscode.workspace.getConfiguration('frontend-test-agent');
            const framework = config.get<string>('defaultFramework', 'react');
            
            progress.report({ increment: 30, message: 'Generating tests with AI...' });
            
            const testContent = await testGenerator.generateTest(
                content,
                framework,
                path.basename(filePath)
            );

            progress.report({ increment: 70, message: 'Writing test file...' });
            
            const outputDir = config.get<string>('testOutputDirectory', '__tests__');
            const testFileName = getTestFileName(filePath, framework);
            const outputPath = path.join(
                path.dirname(filePath),
                outputDir,
                testFileName
            );

            // Ensure output directory exists
            const outputDirPath = path.dirname(outputPath);
            if (!fs.existsSync(outputDirPath)) {
                fs.mkdirSync(outputDirPath, { recursive: true });
            }

            fs.writeFileSync(outputPath, testContent);

            progress.report({ increment: 100, message: 'Tests generated successfully!' });

            // Open the generated test file
            const doc = await vscode.workspace.openTextDocument(outputPath);
            await vscode.window.showTextDocument(doc);

            vscode.window.showInformationMessage(
                `‚úÖ Test file generated: ${testFileName}`
            );
        });
    } catch (error) {
        console.error('Error generating tests:', error);
        vscode.window.showErrorMessage(
            `‚ùå Failed to generate tests: ${error instanceof Error ? error.message : 'Unknown error'}`
        );
    }
}

async function handleRunTests(uri?: vscode.Uri) {
    let testPaths: string[] = [];

    if (uri) {
        const stats = fs.statSync(uri.fsPath);
        if (stats.isFile()) {
            testPaths = [uri.fsPath];
        } else if (stats.isDirectory()) {
            testPaths = getAllTestFiles(uri.fsPath);
        }
    } else {
        // Run all tests in workspace
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders) {
            testPaths = workspaceFolders.flatMap(folder => 
                getAllTestFiles(folder.uri.fsPath)
            );
        }
    }

    if (testPaths.length === 0) {
        vscode.window.showErrorMessage('No test files found to run');
        return;
    }

    try {
        const progressOptions: vscode.ProgressOptions = {
            location: vscode.ProgressLocation.Notification,
            title: 'Running Tests...',
            cancellable: false
        };

        await vscode.window.withProgress(progressOptions, async (progress) => {
            progress.report({ increment: 0, message: 'Preparing test environment...' });
            
            const config = vscode.workspace.getConfiguration('frontend-test-agent');
            const runner = config.get<string>('defaultTestRunner', 'jest');
            
            progress.report({ increment: 20, message: 'Executing tests...' });
            
            const result = await testRunner.runTests(
                testPaths,
                runner,
                progress
            );

            progress.report({ increment: 80, message: 'Generating report...' });
            
            await coverageReporter.generateCoverage(result);
            await testExplorerProvider.refresh();

            progress.report({ increment: 100, message: 'Tests completed!' });

            // Show results
            showTestResults(result);
        });
    } catch (error) {
        console.error('Error running tests:', error);
        vscode.window.showErrorMessage(
            `‚ùå Failed to run tests: ${error instanceof Error ? error.message : 'Unknown error'}`
        );
    }
}

async function handleShowCoverage() {
    try {
        const coveragePath = path.join(
            vscode.workspace.workspaceFolders![0].uri.fsPath,
            'coverage',
            'lcov-report',
            'index.html'
        );

        if (fs.existsSync(coveragePath)) {
            await vscode.commands.executeCommand(
                'vscode.open',
                vscode.Uri.file(coveragePath)
            );
        } else {
            // Run tests with coverage if report doesn't exist
            await vscode.window.showInformationMessage(
                'Coverage report not found. Running tests with coverage...'
            );
            await handleRunTests(undefined);
        }
    } catch (error) {
        console.error('Error showing coverage:', error);
        vscode.window.showErrorMessage(
            `‚ùå Failed to show coverage: ${error instanceof Error ? error.message : 'Unknown error'}`
        );
    }
}

async function handleAnalyzeResults() {
    try {
        const config = vscode.workspace.getConfiguration('frontend-test-agent');
        const workspaceFolder = vscode.workspace.workspaceFolders![0].uri.fsPath;
        
        const analysisResult = await resultAnalyzer.analyzeResults(workspaceFolder);
        
        // Show analysis in webview
        const panel = vscode.window.createWebviewPanel(
            'testAnalysis',
            'Test Result Analysis',
            vscode.ViewColumn.Beside,
            { enableScripts: true }
        );

        panel.webview.html = getAnalysisWebviewHtml(analysisResult);
    } catch (error) {
        console.error('Error analyzing results:', error);
        vscode.window.showErrorMessage(
            `‚ùå Failed to analyze results: ${error instanceof Error ? error.message : 'Unknown error'}`
        );
    }
}

async function handleAutoGenerate(document: vscode.TextDocument) {
    const config = vscode.workspace.getConfiguration('frontend-test-agent');
    const enableAutoGenerate = config.get<boolean>('enableAutoGenerate', false);
    
    if (!enableAutoGenerate) {
        return;
    }

    // Check if this is a frontend file
    const allowedLanguages = [
        'javascript', 'typescript', 
        'javascriptreact', 'typescriptreact', 'vue'
    ];
    
    if (!allowedLanguages.includes(document.languageId)) {
        return;
    }

    // Skip test files
    if (document.fileName.includes('.test.') || document.fileName.includes('.spec.')) {
        return;
    }

    // Add delay to avoid multiple triggers
    const delay = config.get<number>('autoGenerateDelay', 2000);
    await new Promise(resolve => setTimeout(resolve, delay));

    // Auto-generate tests
    await handleGenerateTests(document.uri);
}

function getTestFileName(filePath: string, framework: string): string {
    const ext = path.extname(filePath);
    const baseName = path.basename(filePath, ext);
    
    if (framework === 'vue') {
        return `${baseName}.spec.ts`;
    } else {
        return `${baseName}.test.tsx`;
    }
}

function getAllTestFiles(dir: string): string[] {
    const testFiles: string[] = [];
    
    function walk(currentDir: string) {
        const files = fs.readdirSync(currentDir);
        
        for (const file of files) {
            const fullPath = path.join(currentDir, file);
            const stats = fs.statSync(fullPath);
            
            if (stats.isDirectory()) {
                walk(fullPath);
            } else if (
                file.includes('.test.') || 
                file.includes('.spec.') ||
                file.endsWith('.test.js') ||
                file.endsWith('.test.ts') ||
                file.endsWith('.spec.js') ||
                file.endsWith('.spec.ts')
            ) {
                testFiles.push(fullPath);
            }
        }
    }
    
    walk(dir);
    return testFiles;
}

function showTestResults(result: any) {
    const summary = `
‚úÖ Tests Completed
Passed: ${result.passed}
Failed: ${result.failed}
Skipped: ${result.skipped}
Total: ${result.total}
Duration: ${result.duration}ms
`;

    if (result.failed > 0) {
        vscode.window.showErrorMessage(
            `Tests completed with ${result.failed} failures. Check test explorer for details.`,
            'Show Details'
        ).then(selection => {
            if (selection === 'Show Details') {
                vscode.commands.executeCommand('frontend-test-agent.testExplorer.focus');
            }
        });
    } else {
        vscode.window.showInformationMessage(summary);
    }
}

function getAnalysisWebviewHtml(analysisResult: any): string {
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Result Analysis</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; padding: 20px; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .card { padding: 20px; border-radius: 8px; background-color: #f5f5f5; }
        .pass { color: #10b981; font-weight: bold; }
        .fail { color: #ef4444; font-weight: bold; }
        .slow { color: #f59e0b; font-weight: bold; }
        .section { margin-bottom: 30px; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px; }
        h2 { margin-top: 0; color: #1f2937; }
        ul { list-style-type: none; padding: 0; }
        li { padding: 8px 0; border-bottom: 1px solid #e5e7eb; }
    </style>
</head>
<body>
    <h1>Test Result Analysis</h1>
    
    <div class="summary">
        <div class="card">
            <h3>Total Tests</h3>
            <p style="font-size: 2em;">${analysisResult.total}</p>
        </div>
        <div class="card">
            <h3>Passed</h3>
            <p class="pass" style="font-size: 2em;">${analysisResult.passed}</p>
        </div>
        <div class="card">
            <h3>Failed</h3>
            <p class="fail" style="font-size: 2em;">${analysisResult.failed}</p>
        </div>
        <div class="card">
            <h3>Coverage</h3>
            <p style="font-size: 2em;">${analysisResult.coverage}%</p>
        </div>
    </div>

    <div class="section">
        <h2>üîç Issues Found</h2>
        ${analysisResult.issues.length > 0 ? `
        <ul>
            ${analysisResult.issues.map((issue: any) => `
            <li>
                <strong>${issue.type}</strong> - ${issue.message}
                <br>
                <small>File: ${issue.file}</small>
            </li>
            `).join('')}
        </ul>
        ` : '<p>No issues found! üéâ</p>'}
    </div>

    <div class="section">
        <h2>‚ö° Slow Tests</h2>
        ${analysisResult.slowTests.length > 0 ? `
        <ul>
            ${analysisResult.slowTests.map((test: any) => `
            <li>
                <span class="slow">${test.duration}ms</span> - ${test.name}
            </li>
            `).join('')}
        </ul>
        ` : '<p>No slow tests found! üöÄ</p>'}
    </div>

    <div class="section">
        <h2>üí° Recommendations</h2>
        ${analysisResult.recommendations.length > 0 ? `
        <ul>
            ${analysisResult.recommendations.map((rec: any) => `
            <li>üí° ${rec}</li>
            `).join('')}
        </ul>
        ` : '<p>No specific recommendations. Your tests look great! ‚ú®</p>'}
    </div>
</body>
</html>
    `;
}

function showWelcomeMessage() {
    const message = 'Frontend Test Agent is ready! üöÄ\n\nCommands:\n- Ctrl+Shift+G: Generate tests\n- Ctrl+Shift+R: Run tests\n\nCheck settings for configuration options.';
    
    vscode.window.showInformationMessage(message, 'Got it!');
}

export function deactivate() {
    console.log('Frontend Test Agent has been deactivated');
}