"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
exports.deactivate = deactivate;
const vscode = __importStar(require("vscode"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const testGenerator_1 = require("./testGenerator");
const testRunner_1 = require("./testRunner");
const coverageReporter_1 = require("./coverageReporter");
const resultAnalyzer_1 = require("./resultAnalyzer");
const testExplorer_1 = require("./testExplorer");
let testGenerator;
let testRunner;
let coverageReporter;
let resultAnalyzer;
let testExplorerProvider;
function activate(context) {
    console.log('Frontend Test Agent has been activated!');
    // Initialize services
    const config = vscode.workspace.getConfiguration('frontend-test-agent');
    testGenerator = new testGenerator_1.TestGenerator(config);
    testRunner = new testRunner_1.TestRunner(config);
    coverageReporter = new coverageReporter_1.CoverageReporter(config);
    resultAnalyzer = new resultAnalyzer_1.ResultAnalyzer(config);
    testExplorerProvider = new testExplorer_1.TestExplorerProvider();
    // Register commands
    const generateTestsCommand = vscode.commands.registerCommand('frontend-test-agent.generateTests', async (uri) => {
        await handleGenerateTests(uri);
    });
    const runTestsCommand = vscode.commands.registerCommand('frontend-test-agent.runTests', async (uri) => {
        await handleRunTests(uri);
    });
    const showCoverageCommand = vscode.commands.registerCommand('frontend-test-agent.showCoverage', async () => {
        await handleShowCoverage();
    });
    const analyzeResultsCommand = vscode.commands.registerCommand('frontend-test-agent.analyzeResults', async () => {
        await handleAnalyzeResults();
    });
    // Register views
    vscode.window.registerTreeDataProvider('frontend-test-agent.testExplorer', testExplorerProvider);
    // Register document save listener for auto-generate
    const autoGenerateDisposable = vscode.workspace.onDidSaveTextDocument(async (document) => {
        await handleAutoGenerate(document);
    });
    // Add to subscriptions
    context.subscriptions.push(generateTestsCommand, runTestsCommand, showCoverageCommand, analyzeResultsCommand, autoGenerateDisposable);
    // Show welcome message
    showWelcomeMessage();
}
async function handleGenerateTests(uri) {
    let filePath;
    if (uri) {
        filePath = uri.fsPath;
    }
    else if (vscode.window.activeTextEditor) {
        filePath = vscode.window.activeTextEditor.document.fileName;
    }
    else {
        vscode.window.showErrorMessage('No file selected to generate tests for');
        return;
    }
    try {
        const progressOptions = {
            location: vscode.ProgressLocation.Notification,
            title: 'Generating Tests...',
            cancellable: false
        };
        await vscode.window.withProgress(progressOptions, async (progress) => {
            progress.report({ increment: 0, message: 'Analyzing component...' });
            const content = fs.readFileSync(filePath, 'utf8');
            const config = vscode.workspace.getConfiguration('frontend-test-agent');
            const framework = config.get('defaultFramework', 'react');
            progress.report({ increment: 30, message: 'Generating tests with AI...' });
            const testContent = await testGenerator.generateTest(content, framework, path.basename(filePath));
            progress.report({ increment: 70, message: 'Writing test file...' });
            const outputDir = config.get('testOutputDirectory', '__tests__');
            const testFileName = getTestFileName(filePath, framework);
            const outputPath = path.join(path.dirname(filePath), outputDir, testFileName);
            // Ensure output directory exists
            const outputDirPath = path.dirname(outputPath);
            if (!fs.existsSync(outputDirPath)) {
                fs.mkdirSync(outputDirPath, { recursive: true });
            }
            fs.writeFileSync(outputPath, testContent);
            progress.report({ increment: 100, message: 'Tests generated successfully!' });
            // Open the generated test file
            const doc = await vscode.workspace.openTextDocument(outputPath);
            await vscode.window.showTextDocument(doc);
            vscode.window.showInformationMessage(`‚úÖ Test file generated: ${testFileName}`);
        });
    }
    catch (error) {
        console.error('Error generating tests:', error);
        vscode.window.showErrorMessage(`‚ùå Failed to generate tests: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
async function handleRunTests(uri) {
    let testPaths = [];
    if (uri) {
        const stats = fs.statSync(uri.fsPath);
        if (stats.isFile()) {
            testPaths = [uri.fsPath];
        }
        else if (stats.isDirectory()) {
            testPaths = getAllTestFiles(uri.fsPath);
        }
    }
    else {
        // Run all tests in workspace
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders) {
            testPaths = workspaceFolders.flatMap(folder => getAllTestFiles(folder.uri.fsPath));
        }
    }
    if (testPaths.length === 0) {
        vscode.window.showErrorMessage('No test files found to run');
        return;
    }
    try {
        const progressOptions = {
            location: vscode.ProgressLocation.Notification,
            title: 'Running Tests...',
            cancellable: false
        };
        await vscode.window.withProgress(progressOptions, async (progress) => {
            progress.report({ increment: 0, message: 'Preparing test environment...' });
            const config = vscode.workspace.getConfiguration('frontend-test-agent');
            const runner = config.get('defaultTestRunner', 'jest');
            progress.report({ increment: 20, message: 'Executing tests...' });
            const result = await testRunner.runTests(testPaths, runner, progress);
            progress.report({ increment: 80, message: 'Generating report...' });
            await coverageReporter.generateCoverage(result);
            await testExplorerProvider.refresh();
            progress.report({ increment: 100, message: 'Tests completed!' });
            // Show results
            showTestResults(result);
        });
    }
    catch (error) {
        console.error('Error running tests:', error);
        vscode.window.showErrorMessage(`‚ùå Failed to run tests: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
async function handleShowCoverage() {
    try {
        const coveragePath = path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, 'coverage', 'lcov-report', 'index.html');
        if (fs.existsSync(coveragePath)) {
            await vscode.commands.executeCommand('vscode.open', vscode.Uri.file(coveragePath));
        }
        else {
            // Run tests with coverage if report doesn't exist
            await vscode.window.showInformationMessage('Coverage report not found. Running tests with coverage...');
            await handleRunTests(undefined);
        }
    }
    catch (error) {
        console.error('Error showing coverage:', error);
        vscode.window.showErrorMessage(`‚ùå Failed to show coverage: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
async function handleAnalyzeResults() {
    try {
        const config = vscode.workspace.getConfiguration('frontend-test-agent');
        const workspaceFolder = vscode.workspace.workspaceFolders[0].uri.fsPath;
        const analysisResult = await resultAnalyzer.analyzeResults(workspaceFolder);
        // Show analysis in webview
        const panel = vscode.window.createWebviewPanel('testAnalysis', 'Test Result Analysis', vscode.ViewColumn.Beside, { enableScripts: true });
        panel.webview.html = getAnalysisWebviewHtml(analysisResult);
    }
    catch (error) {
        console.error('Error analyzing results:', error);
        vscode.window.showErrorMessage(`‚ùå Failed to analyze results: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
async function handleAutoGenerate(document) {
    const config = vscode.workspace.getConfiguration('frontend-test-agent');
    const enableAutoGenerate = config.get('enableAutoGenerate', false);
    if (!enableAutoGenerate) {
        return;
    }
    // Check if this is a frontend file
    const allowedLanguages = [
        'javascript', 'typescript',
        'javascriptreact', 'typescriptreact', 'vue'
    ];
    if (!allowedLanguages.includes(document.languageId)) {
        return;
    }
    // Skip test files
    if (document.fileName.includes('.test.') || document.fileName.includes('.spec.')) {
        return;
    }
    // Add delay to avoid multiple triggers
    const delay = config.get('autoGenerateDelay', 2000);
    await new Promise(resolve => setTimeout(resolve, delay));
    // Auto-generate tests
    await handleGenerateTests(document.uri);
}
function getTestFileName(filePath, framework) {
    const ext = path.extname(filePath);
    const baseName = path.basename(filePath, ext);
    if (framework === 'vue') {
        return `${baseName}.spec.ts`;
    }
    else {
        return `${baseName}.test.tsx`;
    }
}
function getAllTestFiles(dir) {
    const testFiles = [];
    function walk(currentDir) {
        const files = fs.readdirSync(currentDir);
        for (const file of files) {
            const fullPath = path.join(currentDir, file);
            const stats = fs.statSync(fullPath);
            if (stats.isDirectory()) {
                walk(fullPath);
            }
            else if (file.includes('.test.') ||
                file.includes('.spec.') ||
                file.endsWith('.test.js') ||
                file.endsWith('.test.ts') ||
                file.endsWith('.spec.js') ||
                file.endsWith('.spec.ts')) {
                testFiles.push(fullPath);
            }
        }
    }
    walk(dir);
    return testFiles;
}
function showTestResults(result) {
    const summary = `
‚úÖ Tests Completed
Passed: ${result.passed}
Failed: ${result.failed}
Skipped: ${result.skipped}
Total: ${result.total}
Duration: ${result.duration}ms
`;
    if (result.failed > 0) {
        vscode.window.showErrorMessage(`Tests completed with ${result.failed} failures. Check test explorer for details.`, 'Show Details').then(selection => {
            if (selection === 'Show Details') {
                vscode.commands.executeCommand('frontend-test-agent.testExplorer.focus');
            }
        });
    }
    else {
        vscode.window.showInformationMessage(summary);
    }
}
function getAnalysisWebviewHtml(analysisResult) {
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Result Analysis</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; padding: 20px; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .card { padding: 20px; border-radius: 8px; background-color: #f5f5f5; }
        .pass { color: #10b981; font-weight: bold; }
        .fail { color: #ef4444; font-weight: bold; }
        .slow { color: #f59e0b; font-weight: bold; }
        .section { margin-bottom: 30px; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px; }
        h2 { margin-top: 0; color: #1f2937; }
        ul { list-style-type: none; padding: 0; }
        li { padding: 8px 0; border-bottom: 1px solid #e5e7eb; }
    </style>
</head>
<body>
    <h1>Test Result Analysis</h1>
    
    <div class="summary">
        <div class="card">
            <h3>Total Tests</h3>
            <p style="font-size: 2em;">${analysisResult.total}</p>
        </div>
        <div class="card">
            <h3>Passed</h3>
            <p class="pass" style="font-size: 2em;">${analysisResult.passed}</p>
        </div>
        <div class="card">
            <h3>Failed</h3>
            <p class="fail" style="font-size: 2em;">${analysisResult.failed}</p>
        </div>
        <div class="card">
            <h3>Coverage</h3>
            <p style="font-size: 2em;">${analysisResult.coverage}%</p>
        </div>
    </div>

    <div class="section">
        <h2>üîç Issues Found</h2>
        ${analysisResult.issues.length > 0 ? `
        <ul>
            ${analysisResult.issues.map((issue) => `
            <li>
                <strong>${issue.type}</strong> - ${issue.message}
                <br>
                <small>File: ${issue.file}</small>
            </li>
            `).join('')}
        </ul>
        ` : '<p>No issues found! üéâ</p>'}
    </div>

    <div class="section">
        <h2>‚ö° Slow Tests</h2>
        ${analysisResult.slowTests.length > 0 ? `
        <ul>
            ${analysisResult.slowTests.map((test) => `
            <li>
                <span class="slow">${test.duration}ms</span> - ${test.name}
            </li>
            `).join('')}
        </ul>
        ` : '<p>No slow tests found! üöÄ</p>'}
    </div>

    <div class="section">
        <h2>üí° Recommendations</h2>
        ${analysisResult.recommendations.length > 0 ? `
        <ul>
            ${analysisResult.recommendations.map((rec) => `
            <li>üí° ${rec}</li>
            `).join('')}
        </ul>
        ` : '<p>No specific recommendations. Your tests look great! ‚ú®</p>'}
    </div>
</body>
</html>
    `;
}
function showWelcomeMessage() {
    const message = 'Frontend Test Agent is ready! üöÄ\n\nCommands:\n- Ctrl+Shift+G: Generate tests\n- Ctrl+Shift+R: Run tests\n\nCheck settings for configuration options.';
    vscode.window.showInformationMessage(message, 'Got it!');
}
function deactivate() {
    console.log('Frontend Test Agent has been deactivated');
}
//# sourceMappingURL=extension.js.map